# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'GetBackupResult',
    'AwaitableGetBackupResult',
    'get_backup',
    'get_backup_output',
]

@pulumi.output_type
class GetBackupResult:
    """
    A collection of values returned by getBackup.
    """
    def __init__(__self__, backup_end_time=None, backup_file_name=None, backup_file_size=None, backup_id=None, backup_metas=None, backup_method=None, backup_name=None, backup_region=None, backup_start_time=None, backup_status=None, backup_type=None, consistent_time=None, create_type=None, db_engine_version=None, db_table_infos=None, download_status=None, engine_type=None, error_message=None, expired_time=None, id=None, instance_id=None, is_encrypted=None, is_expired=None):
        if backup_end_time and not isinstance(backup_end_time, str):
            raise TypeError("Expected argument 'backup_end_time' to be a str")
        pulumi.set(__self__, "backup_end_time", backup_end_time)
        if backup_file_name and not isinstance(backup_file_name, str):
            raise TypeError("Expected argument 'backup_file_name' to be a str")
        pulumi.set(__self__, "backup_file_name", backup_file_name)
        if backup_file_size and not isinstance(backup_file_size, int):
            raise TypeError("Expected argument 'backup_file_size' to be a int")
        pulumi.set(__self__, "backup_file_size", backup_file_size)
        if backup_id and not isinstance(backup_id, str):
            raise TypeError("Expected argument 'backup_id' to be a str")
        pulumi.set(__self__, "backup_id", backup_id)
        if backup_metas and not isinstance(backup_metas, list):
            raise TypeError("Expected argument 'backup_metas' to be a list")
        pulumi.set(__self__, "backup_metas", backup_metas)
        if backup_method and not isinstance(backup_method, str):
            raise TypeError("Expected argument 'backup_method' to be a str")
        pulumi.set(__self__, "backup_method", backup_method)
        if backup_name and not isinstance(backup_name, str):
            raise TypeError("Expected argument 'backup_name' to be a str")
        pulumi.set(__self__, "backup_name", backup_name)
        if backup_region and not isinstance(backup_region, str):
            raise TypeError("Expected argument 'backup_region' to be a str")
        pulumi.set(__self__, "backup_region", backup_region)
        if backup_start_time and not isinstance(backup_start_time, str):
            raise TypeError("Expected argument 'backup_start_time' to be a str")
        pulumi.set(__self__, "backup_start_time", backup_start_time)
        if backup_status and not isinstance(backup_status, str):
            raise TypeError("Expected argument 'backup_status' to be a str")
        pulumi.set(__self__, "backup_status", backup_status)
        if backup_type and not isinstance(backup_type, str):
            raise TypeError("Expected argument 'backup_type' to be a str")
        pulumi.set(__self__, "backup_type", backup_type)
        if consistent_time and not isinstance(consistent_time, str):
            raise TypeError("Expected argument 'consistent_time' to be a str")
        pulumi.set(__self__, "consistent_time", consistent_time)
        if create_type and not isinstance(create_type, str):
            raise TypeError("Expected argument 'create_type' to be a str")
        pulumi.set(__self__, "create_type", create_type)
        if db_engine_version and not isinstance(db_engine_version, str):
            raise TypeError("Expected argument 'db_engine_version' to be a str")
        pulumi.set(__self__, "db_engine_version", db_engine_version)
        if db_table_infos and not isinstance(db_table_infos, list):
            raise TypeError("Expected argument 'db_table_infos' to be a list")
        pulumi.set(__self__, "db_table_infos", db_table_infos)
        if download_status and not isinstance(download_status, str):
            raise TypeError("Expected argument 'download_status' to be a str")
        pulumi.set(__self__, "download_status", download_status)
        if engine_type and not isinstance(engine_type, str):
            raise TypeError("Expected argument 'engine_type' to be a str")
        pulumi.set(__self__, "engine_type", engine_type)
        if error_message and not isinstance(error_message, str):
            raise TypeError("Expected argument 'error_message' to be a str")
        pulumi.set(__self__, "error_message", error_message)
        if expired_time and not isinstance(expired_time, str):
            raise TypeError("Expected argument 'expired_time' to be a str")
        pulumi.set(__self__, "expired_time", expired_time)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if instance_id and not isinstance(instance_id, str):
            raise TypeError("Expected argument 'instance_id' to be a str")
        pulumi.set(__self__, "instance_id", instance_id)
        if is_encrypted and not isinstance(is_encrypted, bool):
            raise TypeError("Expected argument 'is_encrypted' to be a bool")
        pulumi.set(__self__, "is_encrypted", is_encrypted)
        if is_expired and not isinstance(is_expired, bool):
            raise TypeError("Expected argument 'is_expired' to be a bool")
        pulumi.set(__self__, "is_expired", is_expired)

    @property
    @pulumi.getter(name="backupEndTime")
    def backup_end_time(self) -> builtins.str:
        """
        备份创建结束时间（UTC）。
        """
        return pulumi.get(self, "backup_end_time")

    @property
    @pulumi.getter(name="backupFileName")
    def backup_file_name(self) -> builtins.str:
        """
        备份文件名。
        """
        return pulumi.get(self, "backup_file_name")

    @property
    @pulumi.getter(name="backupFileSize")
    def backup_file_size(self) -> builtins.int:
        """
        备份文件大小，单位为字节。
        """
        return pulumi.get(self, "backup_file_size")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> builtins.str:
        """
        备份 ID。
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="backupMetas")
    def backup_metas(self) -> Sequence['outputs.GetBackupBackupMetaResult']:
        """
        创建逻辑备份类型的库表备份时，用于指定要备份的库表信息。
        """
        return pulumi.get(self, "backup_metas")

    @property
    @pulumi.getter(name="backupMethod")
    def backup_method(self) -> builtins.str:
        """
        备份类型，取值：Physical（物理备份）、Logical（逻辑备份）、Snapshot（快照备份）。
        """
        return pulumi.get(self, "backup_method")

    @property
    @pulumi.getter(name="backupName")
    def backup_name(self) -> builtins.str:
        """
        备份的名称。
        """
        return pulumi.get(self, "backup_name")

    @property
    @pulumi.getter(name="backupRegion")
    def backup_region(self) -> builtins.str:
        """
        备份所在区域。
        """
        return pulumi.get(self, "backup_region")

    @property
    @pulumi.getter(name="backupStartTime")
    def backup_start_time(self) -> builtins.str:
        """
        备份创建开始时间（UTC）。
        """
        return pulumi.get(self, "backup_start_time")

    @property
    @pulumi.getter(name="backupStatus")
    def backup_status(self) -> builtins.str:
        """
        备份状态，取值：Success（成功）、Failed（失败）、Running（执行中）。
        """
        return pulumi.get(self, "backup_status")

    @property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> builtins.str:
        """
        备份方式，取值：Full（全量/库表备）、Increment（增量备份）、DumpAll（全库备份）。
        """
        return pulumi.get(self, "backup_type")

    @property
    @pulumi.getter(name="consistentTime")
    def consistent_time(self) -> builtins.str:
        """
        一致性时间点。
        """
        return pulumi.get(self, "consistent_time")

    @property
    @pulumi.getter(name="createType")
    def create_type(self) -> builtins.str:
        """
        备份创建者，取值：System（系统）、User（用户）。
        """
        return pulumi.get(self, "create_type")

    @property
    @pulumi.getter(name="dbEngineVersion")
    def db_engine_version(self) -> builtins.str:
        """
        兼容版本。取值：MySQL*5*7：MySQL 5.7 版本。MySQL*8*0：MySQL 8.0 版本。
        """
        return pulumi.get(self, "db_engine_version")

    @property
    @pulumi.getter(name="dbTableInfos")
    def db_table_infos(self) -> Sequence['outputs.GetBackupDbTableInfoResult']:
        """
        库表信息列表。
        """
        return pulumi.get(self, "db_table_infos")

    @property
    @pulumi.getter(name="downloadStatus")
    def download_status(self) -> builtins.str:
        """
        下载状态。
        """
        return pulumi.get(self, "download_status")

    @property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> builtins.str:
        """
        数据库引擎类型。取值：InnoDB：InnoDB 引擎。RocksDB：RocksDB 引擎。
        """
        return pulumi.get(self, "engine_type")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> builtins.str:
        """
        备份失败的错误信息。
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> builtins.str:
        """
        备份过期时间（UTC）。
        """
        return pulumi.get(self, "expired_time")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Uniquely identifies the resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> builtins.str:
        """
        实例 ID。
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="isEncrypted")
    def is_encrypted(self) -> builtins.bool:
        """
        是否加密。
        """
        return pulumi.get(self, "is_encrypted")

    @property
    @pulumi.getter(name="isExpired")
    def is_expired(self) -> builtins.bool:
        """
        是否已过期。
        """
        return pulumi.get(self, "is_expired")


class AwaitableGetBackupResult(GetBackupResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetBackupResult(
            backup_end_time=self.backup_end_time,
            backup_file_name=self.backup_file_name,
            backup_file_size=self.backup_file_size,
            backup_id=self.backup_id,
            backup_metas=self.backup_metas,
            backup_method=self.backup_method,
            backup_name=self.backup_name,
            backup_region=self.backup_region,
            backup_start_time=self.backup_start_time,
            backup_status=self.backup_status,
            backup_type=self.backup_type,
            consistent_time=self.consistent_time,
            create_type=self.create_type,
            db_engine_version=self.db_engine_version,
            db_table_infos=self.db_table_infos,
            download_status=self.download_status,
            engine_type=self.engine_type,
            error_message=self.error_message,
            expired_time=self.expired_time,
            id=self.id,
            instance_id=self.instance_id,
            is_encrypted=self.is_encrypted,
            is_expired=self.is_expired)


def get_backup(id: Optional[builtins.str] = None,
               opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetBackupResult:
    """
    Data Source schema for Byteplus::RDSMySQL::Backup


    :param builtins.str id: Uniquely identifies the resource.
    """
    __args__ = dict()
    __args__['id'] = id
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('bytepluscc:rdsmysql/getBackup:getBackup', __args__, opts=opts, typ=GetBackupResult).value

    return AwaitableGetBackupResult(
        backup_end_time=pulumi.get(__ret__, 'backup_end_time'),
        backup_file_name=pulumi.get(__ret__, 'backup_file_name'),
        backup_file_size=pulumi.get(__ret__, 'backup_file_size'),
        backup_id=pulumi.get(__ret__, 'backup_id'),
        backup_metas=pulumi.get(__ret__, 'backup_metas'),
        backup_method=pulumi.get(__ret__, 'backup_method'),
        backup_name=pulumi.get(__ret__, 'backup_name'),
        backup_region=pulumi.get(__ret__, 'backup_region'),
        backup_start_time=pulumi.get(__ret__, 'backup_start_time'),
        backup_status=pulumi.get(__ret__, 'backup_status'),
        backup_type=pulumi.get(__ret__, 'backup_type'),
        consistent_time=pulumi.get(__ret__, 'consistent_time'),
        create_type=pulumi.get(__ret__, 'create_type'),
        db_engine_version=pulumi.get(__ret__, 'db_engine_version'),
        db_table_infos=pulumi.get(__ret__, 'db_table_infos'),
        download_status=pulumi.get(__ret__, 'download_status'),
        engine_type=pulumi.get(__ret__, 'engine_type'),
        error_message=pulumi.get(__ret__, 'error_message'),
        expired_time=pulumi.get(__ret__, 'expired_time'),
        id=pulumi.get(__ret__, 'id'),
        instance_id=pulumi.get(__ret__, 'instance_id'),
        is_encrypted=pulumi.get(__ret__, 'is_encrypted'),
        is_expired=pulumi.get(__ret__, 'is_expired'))
def get_backup_output(id: Optional[pulumi.Input[builtins.str]] = None,
                      opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetBackupResult]:
    """
    Data Source schema for Byteplus::RDSMySQL::Backup


    :param builtins.str id: Uniquely identifies the resource.
    """
    __args__ = dict()
    __args__['id'] = id
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('bytepluscc:rdsmysql/getBackup:getBackup', __args__, opts=opts, typ=GetBackupResult)
    return __ret__.apply(lambda __response__: GetBackupResult(
        backup_end_time=pulumi.get(__response__, 'backup_end_time'),
        backup_file_name=pulumi.get(__response__, 'backup_file_name'),
        backup_file_size=pulumi.get(__response__, 'backup_file_size'),
        backup_id=pulumi.get(__response__, 'backup_id'),
        backup_metas=pulumi.get(__response__, 'backup_metas'),
        backup_method=pulumi.get(__response__, 'backup_method'),
        backup_name=pulumi.get(__response__, 'backup_name'),
        backup_region=pulumi.get(__response__, 'backup_region'),
        backup_start_time=pulumi.get(__response__, 'backup_start_time'),
        backup_status=pulumi.get(__response__, 'backup_status'),
        backup_type=pulumi.get(__response__, 'backup_type'),
        consistent_time=pulumi.get(__response__, 'consistent_time'),
        create_type=pulumi.get(__response__, 'create_type'),
        db_engine_version=pulumi.get(__response__, 'db_engine_version'),
        db_table_infos=pulumi.get(__response__, 'db_table_infos'),
        download_status=pulumi.get(__response__, 'download_status'),
        engine_type=pulumi.get(__response__, 'engine_type'),
        error_message=pulumi.get(__response__, 'error_message'),
        expired_time=pulumi.get(__response__, 'expired_time'),
        id=pulumi.get(__response__, 'id'),
        instance_id=pulumi.get(__response__, 'instance_id'),
        is_encrypted=pulumi.get(__response__, 'is_encrypted'),
        is_expired=pulumi.get(__response__, 'is_expired')))
